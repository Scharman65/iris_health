import 'dart:typed_data';
import 'dart:convert';
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:camera/camera.dart';
import 'package:http/http.dart' as http;
import 'package:image/image.dart' as img;

import 'summary_screen.dart';

const String kAiEndpoint = String.fromEnvironment(
  'AI_ENDPOINT',
  defaultValue: 'http://127.0.0.1:8000/analyze',
);

class CameraScreen extends StatefulWidget {
  final String examId;
  final int age;
  final String gender;

  const CameraScreen({
    Key? key,
    required this.examId,
    required this.age,
    required this.gender,
  }) : super(key: key);

  @override
  State<CameraScreen> createState() => _CameraScreenState();
}

class _CameraScreenState extends State<CameraScreen> {
  CameraController? _controller;
  bool _initializing = true;

  Uint8List? _leftBytes;
  Uint8List? _rightBytes;

  bool _leftDone = false;
  bool _rightDone = false;
  bool _isCapturing = false;

  bool get _ready => _leftDone && _rightDone;

  @override
  void initState() {
    super.initState();
    _initCamera();
  }

  Future<void> _initCamera() async {
    final cameras = await availableCameras();
    final camera = cameras.firstWhere(
      (c) => c.lensDirection == CameraLensDirection.back,
      orElse: () => cameras.first,
    );

    _controller = CameraController(
      camera,
      ResolutionPreset.max,
      enableAudio: false,
    );

    await _controller!.initialize();

    // --- фикс айфона: getMaxZoomLevel(), а не maxZoomLevel ---
    final maxZoom = await _controller!.getMaxZoomLevel();
    final targetZoom = min(maxZoom, 2.2);
    await _controller!.setZoomLevel(targetZoom);

    setState(() => _initializing = false);
  }

  @override
  void dispose() {
    _controller?.dispose();
    super.dispose();
  }

  Future<Uint8List> _cutCircle(Uint8List bytes) async {
    final decoded = img.decodeImage(bytes)!;
    final size = min(decoded.width, decoded.height);
    final crop = img.copyCrop(
      decoded,
      x: (decoded.width - size) ~/ 2,
      y: (decoded.height - size) ~/ 2,
      width: size,
      height: size,
    );

    final mask = img.Image(width: size, height: size);
    img.fill(mask, color: img.ColorRgba8(0, 0, 0, 0));

    final cx = size / 2;
    final cy = size / 2;
    final r = size / 2;

    for (int y = 0; y < size; y++) {
      for (int x = 0; x < size; x++) {
        final dx = x - cx;
        final dy = y - cy;
        if (dx * dx + dy * dy <= r * r) {
          mask.setPixel(x, y, crop.getPixel(x, y));
        }
      }
    }

    return Uint8List.fromList(img.encodeJpg(mask, quality: 95));
  }

  }
}    }
    return sum / count;
  }

  double _sharp(img.Image im) {n
    final w = im.width;n
    final h = im.height;n
    double sum = 0;n
    int count = 0;n
n
    const kernel = [n
      0,  1, 0,n
      1, -4, 1,n
      0,  1, 0,n
    ];n
n
    for (int y = 1; y < h - 1; y++) {n
      for (int x = 1; x < w - 1; x++) {n
        double lap = 0;n
        int k = 0;n
        for (int ky = -1; ky <= 1; ky++) {n
          for (int kx = -1; kx <= 1; kx++) {n
            final px = img.getLuminance(im.getPixel(x + kx, y + ky));n
            lap += px * kernel[k++];n
          }n
        }n
        sum += lap * lap;n
        count++;n
      }n
    }n
    return sum / max(count, 1);n
  }n
  Future<void> _capture(String side) async {
    if (_controller == null) return;

    setState(() => _isCapturing = true);

    final file = await _controller!.takePicture();
    final bytes = await file.readAsBytes();

    final cropped = await _cutCircle(bytes);
    final decoded = img.decodeImage(cropped)!;
    final sharpness = _sharpness(decoded);

    if (sharpness < 12) {
      setState(() => _isCapturing = false);
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Фото размыто — попробуй ещё раз')),
      );
      return;
    }

    setState(() {
      if (side == 'left') {
        _leftBytes = cropped;
        _leftDone = true;
      } else {
        _rightBytes = cropped;
        _rightDone = true;
      }
      _isCapturing = false;
    });
  }

  Future<Map<String, dynamic>> _callServer(String side, Uint8List bytes) async {
    final req = http.MultipartRequest('POST', Uri.parse(kAiEndpoint));

    req.fields['exam_id'] = widget.examId;
    req.fields['age'] = widget.age.toString();
    req.fields['gender'] = widget.gender;
    req.fields['locale'] = 'ru';
    req.fields['task'] = 'Иридодиагностика';

    req.files.add(
      http.MultipartFile.fromBytes(
        side,
        bytes,
        filename: '$side.jpg',
      ),
    );

    final resp = await req.send();
    final body = await resp.stream.bytesToString();
    return jsonDecode(body);
  }

  Future<void> _analyze() async {
    final leftRes = await _callServer('left', _leftBytes!);
    final rightRes = await _callServer('right', _rightBytes!);

    final result = rightRes['status'] == 'waiting' ? leftRes : rightRes;

    if (!mounted) return;

    Navigator.pushReplacement(
      context,
      MaterialPageRoute(
        builder: (_) => SummaryScreen(examId: widget.examId, result: result),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    if (_initializing) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }

    return Scaffold(
      appBar: AppBar(
        title: Text('Irido Diagnostics (${widget.examId})'),
      ),
      body: SafeArea(
        child: Column(
          children: [
            Expanded(child: CameraPreview(_controller!)),
            Container(
              padding: const EdgeInsets.all(12),
              child: Column(
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                    children: [
                      ElevatedButton(
                        onPressed: _isCapturing ? null : () => _capture('left'),
                        child: Text(_leftDone ? 'Левый ✓' : 'Снять левый'),
                      ),
                      ElevatedButton(
                        onPressed:
                            _isCapturing ? null : () => _capture('right'),
                        child: Text(_rightDone ? 'Правый ✓' : 'Снять правый'),
                      ),
                    ],
                  ),
                  const SizedBox(height: 12),
                  ElevatedButton(
                    onPressed: _ready && !_isCapturing ? _analyze : null,
                    child: const Text('Отправить на анализ'),
                  ),
                ],
              ),
            )
          ],
        ),
      ),
    );
  }
}
