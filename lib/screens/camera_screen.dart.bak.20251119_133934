import 'dart:io';
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:camera/camera.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import 'package:image/image.dart' as img;

import '../services/diagnosis_service.dart';
import '../screens/diagnosis_summary_screen.dart';

enum EyeSide { left, right }

class CameraScreen extends StatefulWidget {
  final String examId;
  final int age;
  final String gender;

  const CameraScreen({
    super.key,
    required this.examId,
    required this.age,
    required this.gender,
  });

  @override
  State<CameraScreen> createState() => _CameraScreenState();
}

class _CameraScreenState extends State<CameraScreen> {
  CameraController? _controller;
  bool _ready = false;

  bool _leftDone = false;
  Uint8List? _leftBytes;
  Uint8List? _rightBytes;

  bool _isCapturing = false;

  // минимальная резкость для допуска
  final double _minSharp = 1500.0;

  @override
  void initState() {
    super.initState();
    _initCamera();
  }

  Future<void> _initCamera() async {
    final cams = await availableCameras();

    // iPhone macro (telephoto 77мм у 13 Pro)
    final macroCam = cams.firstWhere(
      (c) => c.lensDirection == CameraLensDirection.back && c.name.contains("Tele"),
      orElse: () => cams.firstWhere(
        (c) => c.lensDirection == CameraLensDirection.back,
        orElse: () => cams.first,
      ),
    );

    _controller = CameraController(
      macroCam,
      ResolutionPreset.max,
      enableAudio: false,
      imageFormatGroup: ImageFormatGroup.jpeg,
    );

    await _controller!.initialize();

    // макро-настройки
    try {
      await _controller!.setFocusMode(FocusMode.locked);
      await _controller!.setExposureMode(ExposureMode.locked);
      await _controller!.setZoomLevel(2.5);
      await _controller!.setExposureOffset(0.0);
      await _controller!.setFlashMode(FlashMode.off);
    } catch (_) {}

    if (mounted) setState(() => _ready = true);
  }

  // анализ резкости
  double _sharpness(Uint8List bytes) {
    final raw = img.decodeImage(bytes);
    if (raw == null) return 0;

    final g = img.grayscale(raw);
    final lap = img.laplacian(g);

    double sum = 0;
    for (final px in lap.data) {
      sum += px * px;
    }
    return sum / lap.length;
  }

  // квадратный превью без искажений
  Widget _previewWithOverlay() {
    if (_controller == null || !_controller!.value.isInitialized) {
      return const Center(child: CircularProgressIndicator());
    }

    final ar = _controller!.value.aspectRatio;

    return Center(
      child: AspectRatio(
        aspectRatio: ar,
        child: CameraPreview(_controller!),
      ),
    );
  }

  Future<void> _saveSide(EyeSide side, Uint8List bytes) async {
    final dir = await getApplicationDocumentsDirectory();
    final folder = Directory(p.join(dir.path, 'exams', widget.examId));
    await folder.create(recursive: true);

    final path = p.join(folder.path, side == EyeSide.left ? "left.jpg" : "right.jpg");

    // сохраняем как есть (обрезка — позже)
    await File(path).writeAsBytes(bytes, flush: true);
  }

  Future<Uint8List?> _captureValidated() async {
    if (_isCapturing) return null;
    _isCapturing = true;

    try {
      final file = await _controller!.takePicture();
      final bytes = await file.readAsBytes();

      final sharp = _sharpness(bytes);
      debugPrint("photo: sharp=$sharp");

      if (sharp < _minSharp) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text("Фото недостаточно резкое — переснимите.")),
          );
        }
        return null;
      }

      return bytes;
    } finally {
      _isCapturing = false;
    }
  }

  Future<void> _process() async {
    if (!_leftDone) {
      final bytes = await _captureValidated();
      if (bytes == null) return;

      _leftBytes = bytes;
      _leftDone = true;

      await _saveSide(EyeSide.left, bytes);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text("Теперь правый глаз")),
        );
      }
      return;
    }

    if (_leftDone && _rightBytes == null) {
      final bytes = await _captureValidated();
      if (bytes == null) return;

      _rightBytes = bytes;

      await _saveSide(EyeSide.right, bytes);

      final dir = await getApplicationDocumentsDirectory();
      final folder = p.join(dir.path, 'exams', widget.examId);

      final leftPath = p.join(folder, 'left.jpg');
      final rightPath = p.join(folder, 'right.jpg');

      final result = await DiagnosisService.analyzeAndSave(
        examId: widget.examId,
        leftPath: leftPath,
        rightPath: rightPath,
        age: widget.age,
        gender: widget.gender,
      );

      if (!mounted) return;

      Navigator.pushReplacement(
        context,
        MaterialPageRoute(
          builder: (_) => DiagnosisSummaryScreen(
            examId: widget.examId,
            leftPath: leftPath,
            rightPath: rightPath,
            aiResult: result,
          ),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(
          !_leftDone ? "Левый глаз • ${widget.examId}" : "Правый глаз • ${widget.examId}",
        ),
      ),
      body: !_ready
          ? const Center(child: CircularProgressIndicator())
          : Stack(
              children: [
                Positioned.fill(child: _previewWithOverlay()),
                Align(
                  alignment: Alignment.bottomCenter,
                  child: Padding(
                    padding: const EdgeInsets.all(28.0),
                    child: FloatingActionButton(
                      backgroundColor: Colors.blueAccent,
                      onPressed: _process,
                      child: const Icon(Icons.camera),
                    ),
                  ),
                ),
              ],
            ),
    );
  }
}
