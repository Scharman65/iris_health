import 'dart:convert';
import 'dart:io';

import 'package:archive/archive.dart';
import 'package:archive/archive_io.dart';
import 'package:file_selector/file_selector.dart';
import 'package:hive/hive.dart';
import 'package:mime/mime.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';

import '../models/diagnosis_model.dart';
import '../models/gender.dart';

class ExportImportService {
  static const int formatVersion = 1;

  static String _safe(String s) => s.replaceAll(RegExp(r'[^a-zA-Z0-9._-]'), '_');

  static Future<Directory> _tmpDir() async {
    final d = await getTemporaryDirectory();
    final dir = Directory(p.join(d.path, 'irida_export'));
    if (dir.existsSync()) dir.deleteSync(recursive: true);
    dir.createSync(recursive: true);
    return dir;
  }

  static Map<String, dynamic> _manifest({required String appVersion, required int count}) {
    return {
      'formatVersion': formatVersion,
      'createdAt': DateTime.now().toUtc().toIso8601String(),
      'appVersion': appVersion,
      'diagnosesCount': count,
      'notes': 'IRIDA export v1 (cropped images only)',
    };
  }

  static Future<String> exportZip({required String appVersion}) async {
    final box = Hive.box<Diagnosis>('diagnoses');
    final all = box.values.toList().cast<Diagnosis>();

    final tmp = await _tmpDir();
    final imagesDir = Directory(p.join(tmp.path, 'images'));
    imagesDir.createSync(recursive: true);

    final diagnosesJson = <Map<String, dynamic>>[];

    for (final d in all) {
      final idSafe = _safe(d.id);

      final leftSrc = File(d.leftEyeImagePath);
      final rightSrc = File(d.rightEyeImagePath);

      final dstDir = Directory(p.join(imagesDir.path, idSafe));
      dstDir.createSync(recursive: true);

      final leftDst = File(p.join(dstDir.path, 'left.jpg'));
      final rightDst = File(p.join(dstDir.path, 'right.jpg'));

      if (leftSrc.existsSync()) {
        leftDst.writeAsBytesSync(leftSrc.readAsBytesSync(), flush: true);
      }
      if (rightSrc.existsSync()) {
        rightDst.writeAsBytesSync(rightSrc.readAsBytesSync(), flush: true);
      }

      diagnosesJson.add({
        'id': d.id,
        'createdAt': d.dateTime.toUtc().toIso8601String(),
        'birthYear': d.birthYear,
        'gender': d.gender.name,
        'leftEyeImagePath': p.posix.join('images', idSafe, 'left.jpg'),
        'rightEyeImagePath': p.posix.join('images', idSafe, 'right.jpg'),
        'ai': d.aiResultJson,
      });
    }

    File(p.join(tmp.path, 'manifest.json')).writeAsStringSync(
      jsonEncode(_manifest(appVersion: appVersion, count: all.length)),
      flush: true,
    );

    File(p.join(tmp.path, 'diagnoses.json')).writeAsStringSync(
      jsonEncode({'items': diagnosesJson}),
      flush: true,
    );

    final zipPath = p.join(tmp.path, 'irida_export_v1.zip');
    final encoder = ZipFileEncoder();
    encoder.create(zipPath);
    encoder.addFile(File(p.join(tmp.path, 'manifest.json')));
    encoder.addFile(File(p.join(tmp.path, 'diagnoses.json')));
    encoder.addDirectory(imagesDir, includeDirName: true);
    encoder.close();

    final bytes = File(zipPath).readAsBytesSync();
    final name = 'irida_export_${DateTime.now().toUtc().toIso8601String().replaceAll(':', '-')}.zip';

    final mime = lookupMimeType(name) ?? 'application/zip';
    final xfile = XFile.fromData(bytes, name: name, mimeType: mime);

    final save = await getSaveLocation(suggestedName: name);
    if (save == null) throw Exception('Export cancelled');

    final out = File(save.path);
    out.writeAsBytesSync(await xfile.readAsBytes(), flush: true);
    return out.path;
  }

  static Future<int> importZip({bool merge = true}) async {
    final typeGroup = XTypeGroup(label: 'IRIDA ZIP', extensions: const ['zip']);
    final xfile = await openFile(acceptedTypeGroups: [typeGroup]);
    if (xfile == null) throw Exception('Import cancelled');

    final bytes = await xfile.readAsBytes();
    final archive = ZipDecoder().decodeBytes(bytes);

    Map<String, dynamic>? manifest;
    List<dynamic>? items;

    final tmp = await _tmpDir();

    for (final f in archive) {
      if (!f.isFile) continue;
      final name = f.name.replaceAll('\\', '/');

      if (name == 'manifest.json') {
        manifest = jsonDecode(utf8.decode(f.content as List<int>)) as Map<String, dynamic>;
      } else if (name == 'diagnoses.json') {
        final m = jsonDecode(utf8.decode(f.content as List<int>)) as Map<String, dynamic>;
        items = (m['items'] is List) ? (m['items'] as List) : <dynamic>[];
      } else if (name.startsWith('images/')) {
        final out = File(p.join(tmp.path, name));
        out.parent.createSync(recursive: true);
        out.writeAsBytesSync(f.content as List<int>, flush: true);
      }
    }

    if (manifest == null || items == null) {
      throw Exception('Invalid ZIP: missing manifest.json or diagnoses.json');
    }

    final fv = (manifest!['formatVersion'] is num)
        ? (manifest!['formatVersion'] as num).toInt()
        : int.tryParse(manifest!['formatVersion']?.toString() ?? '') ?? 0;

    if (fv != formatVersion) {
      throw Exception('Unsupported export formatVersion=$fv');
    }

    final box = Hive.box<Diagnosis>('diagnoses');

    final appDir = await getApplicationDocumentsDirectory();
    final examsDir = Directory(p.join(appDir.path, 'exams'));
    examsDir.createSync(recursive: true);

    int imported = 0;

    for (final raw in items!) {
      if (raw is! Map) continue;
      final m = Map<String, dynamic>.from(raw);

      final id = (m['id'] ?? '').toString();
      if (id.isEmpty) continue;

      if (!merge && box.values.any((e) => e.id == id)) continue;

      final createdAt = DateTime.tryParse(m['createdAt']?.toString() ?? '') ?? DateTime.now();
      final birthYear = (m['birthYear'] is num)
          ? (m['birthYear'] as num).toInt()
          : int.tryParse(m['birthYear']?.toString() ?? '') ?? 0;

      final genderStr = (m['gender'] ?? '').toString();
      final gender = genderStr == 'female' ? Gender.female : Gender.male;

      final idSafe = _safe(id);

      final srcDir = Directory(p.join(tmp.path, 'images', idSafe));
      final dstDir = Directory(p.join(examsDir.path, idSafe));
      dstDir.createSync(recursive: true);

      final leftSrc = File(p.join(srcDir.path, 'left.jpg'));
      final rightSrc = File(p.join(srcDir.path, 'right.jpg'));

      final leftDst = File(p.join(dstDir.path, 'left.jpg'));
      final rightDst = File(p.join(dstDir.path, 'right.jpg'));

      if (leftSrc.existsSync()) leftDst.writeAsBytesSync(leftSrc.readAsBytesSync(), flush: true);
      if (rightSrc.existsSync()) rightDst.writeAsBytesSync(rightSrc.readAsBytesSync(), flush: true);

      final diag = Diagnosis(
        id: id,
        dateTime: createdAt.toLocal(),
        birthYear: birthYear,
        gender: gender,
        leftEyeImagePath: leftDst.path,
        rightEyeImagePath: rightDst.path,
        aiResultJson: m['ai']?.toString() ?? '',
      );

      final existingKey = box.keys.cast<dynamic?>().firstWhere(
        (k) => (box.get(k)?.id == id),
        orElse: () => null,
      );

      if (existingKey != null) {
        await box.put(existingKey, diag);
      } else {
        await box.add(diag);
      }

      imported++;
    }

    return imported;
  }
}
