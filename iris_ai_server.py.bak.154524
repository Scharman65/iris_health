
from fastapi import FastAPI, UploadFile, File, Form, Request
from fastapi.responses import JSONResponse
from fastapi.staticfiles import StaticFiles
from pathlib import Path
from typing import Any, Dict, List
from PIL import Image
import numpy as np
import json, os

from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
from reportlab.lib.utils import ImageReader
from reportlab.pdfbase import pdfmetrics
_HAS_RTL = False

BASE_DIR = Path(__file__).parent.resolve()
INBOX = BASE_DIR / "ai_inbox"
INBOX.mkdir(parents=True, exist_ok=True)

app = FastAPI()

    app.mount("/files", StaticFiles(directory=str(INBOX)), name="files")

    pass

def _shape_rtl(text: str, locale: str) -> str:
    lc = (locale or "en").split("-",1)[0].lower()
    if not isinstance(text, str):
        text = str(text)
    if lc in ("ar","fa","ur"):
        if _HAS_RTL:

                return _bidi_get_display(arabic_reshaper.reshape(text))

                return text[::-1]
        return text[::-1]
    if lc == "he":
        if _HAS_RTL:

                return _bidi_get_display(text)

                return text[::-1]
        return text[::-1]
    return text

def _ensure_fonts() -> None:
        pass
        pass
        pass

def _pick_font(locale: str | None) -> str:
    l = (locale or "en").split("-",1)[0].lower()
    if l in ("ar","fa","ur"):
        return "Helvetica"
    if l == "he":
        return "Helvetica"
    return "Helvetica"

def _wrap_lines_for_pdf(text: str, max_width: float, font_name: str, font_size: int, locale: str) -> List[str]:
    words = text.split(" ")
    lines, cur = [], ""
    for w in words:
        test = (cur + " " + w).strip()
        if pdfmetrics.stringWidth(test, font_name, font_size) <= max_width:
            cur = test
        else:
            if cur:
                lines.append(cur)
            cur = w
    if cur:
        lines.append(cur)
    lines = [ _shape_rtl(line, locale) for line in lines ]
    return lines

def _basic_quality(img: Image.Image) -> Dict[str, float]:
    g = np.asarray(img.convert("L"), dtype=np.uint8)
    bright = float(g.mean()/255.0)
    glare = float((g > 245).mean())
    gx = np.abs(np.diff(g.astype(np.float32), axis=1)).mean()
    gy = np.abs(np.diff(g.astype(np.float32), axis=0)).mean()
    sharp_lapvar = float(gx + gy)
    return {"brightness": bright, "glare": glare, "sharp_lapvar": sharp_lapvar}

def _find_radii(img: Image.Image) -> Dict[str, int]:
    w, h = img.size; cx, cy = w//2, h//2
    g = np.asarray(img.convert("L"), dtype=np.uint8)
    prof = g[cy, :]
    thr = int(np.percentile(prof, 20))
    left = np.argmax(prof[:cx] > thr)
    right = w - 1 - np.argmax(prof[::-1] > thr)
    r_iris = max(cx - left, right - cx)
    r_pupil = max(10, int(0.35 * r_iris))
    return {"r_pupil": int(r_pupil), "r_iris": int(r_iris)}

def _flags_quality(q: Dict[str, float]) -> Dict[str, Any]:
    flags, ok = [], True
    if q.get("brightness", 0) < 0.12: ok=False; flags.append({"code":"too_dark","msg":"Недостаточная освещённость"})
    if q.get("glare", 0) > 0.12: ok=False; flags.append({"code":"glare","msg":"Сильные блики"})
    if q.get("sharp_lapvar", 0) < 1500: ok=False; flags.append({"code":"blurry","msg":"Низкая резкость"})
    return {"ok": ok, "flags": flags}

def _sector_label(angle_sector: int, ring: int, n_ang: int = 24, n_rad: int = 5) -> str:
    organs = {
        0:"Голова/лицо",1:"Голова/лицо",2:"Шея/гортань",3:"Щитовидная",
        4:"Плечевой пояс",5:"Грудной отдел",6:"Сердце/перикард",7:"Желудок",
        8:"Тонкая кишка",9:"Тонкая кишка",10:"Толстая(восх.)",11:"Толстая(попер.)",
        12:"Толстая(нисх.)",13:"Почки/надпоч.",14:"Мочевой тракт",15:"Половые органы",
        16:"Поясница/крестец",17:"Суставы НК",18:"Селезёнка/лимфа",19:"ЖКТ(общ)",
        20:"ЖКТ(общ)",21:"Бронхи",22:"Глотка/миндалины",23:"Голова/лицо",
    }
    layers = {0:"околозрачк. зона",1:"вн. радужка",2:"ср. радужка",3:"нар. радужка",4:"краевой пояс"}
    return f"{organs.get(angle_sector % n_ang,'Зона?')} — {layers.get(ring % n_rad,f'слой {ring}')}"

def _normalize01(x: np.ndarray) -> np.ndarray:
    mn, mx = x.min(), x.max()
    if mx - mn < 1e-9:
        return np.zeros_like(x)
    return (x - mn) / (mx - mn)

def _score_map_and_features(img: Image.Image) -> Dict[str, Any]:
    g = np.asarray(img.convert("L"), dtype=np.uint8)
    h, w = g.shape; cx, cy = w // 2, h // 2
    rinfo = _find_radii(img); r_in = rinfo["r_pupil"]; r_out = rinfo["r_iris"]
    n_ang, n_rad = 24, 5
    feats: List[Dict[str, Any]] = []
    ring_edges = np.linspace(r_in, r_out, n_rad + 1, dtype=int)
    ang_edges = np.linspace(0, 2*np.pi, n_ang + 1)
    yy, xx = np.indices(g.shape)
    rr = np.sqrt((xx - cx)**2 + (yy - cy)**2)
    aa = (np.arctan2(yy - cy, xx - cx) + 2*np.pi) % (2*np.pi)
    mask_iris = (rr >= r_in) & (rr <= r_out)
    strip = g.copy(); strip[~mask_iris] = 0
    for ia in range(n_ang):
        a0, a1 = ang_edges[ia], ang_edges[ia+1]; am = (aa >= a0) & (aa < a1)
        for ir in range(n_rad):
            r0, r1 = ring_edges[ir], ring_edges[ir+1]; rm = (rr >= r0) & (rr < r1)
            sel = strip[am & rm]
            if sel.size == 0:
                mean = std = edged = lapv = 0.0
            else:
                mean = float(sel.mean()/255.0)
                std  = float(sel.std()/255.0)
                edged = float((sel > np.median(sel)).mean())
                gx = np.abs(np.diff(sel.astype(np.float32), axis=1)).mean() if sel.ndim==2 else 0
                gy = np.abs(np.diff(sel.astype(np.float32), axis=0)).mean() if sel.ndim==2 else 0
                lapv = float(gx + gy)
            feats.append({"angle_sector": ia, "ring": ir, "mean": mean, "std": std, "edge_density": edged, "lapvar": lapv})
    tmp = np.array([[f["std"], f["edge_density"], 1.0-abs(0.5-f["mean"]), f["lapvar"]] for f in feats], dtype=np.float32)
    s_std = _normalize01(tmp[:,0]); s_edg = _normalize01(tmp[:,1]); s_cmn = _normalize01(tmp[:,2]); s_lap = _normalize01(tmp[:,3])
    score = _normalize01(0.4*s_std + 0.4*s_edg + 0.2*s_cmn + 0.2*s_lap)
    score_map = score.reshape(24, 5).tolist()
    return {"quality": {**_basic_quality(img), **_find_radii(img)}, "features": feats, "score_map": score_map}

def _top_flags(feats: List[Dict[str, Any]], k: int = 5) -> List[Dict[str, Any]]:
    arr = []
    for f in feats:
        s = 0.4*f["std"] + 0.4*f["edge_density"] + 0.2*(1.0-abs(0.5-f["mean"])) + 0.2*f["lapvar"]
        arr.append((s, f))
    arr.sort(key=lambda t: t[0], reverse=True)
    top = []
    for s, f in arr[:k]:
        top.append({"label": _sector_label(f["angle_sector"], f["ring"]), "score": float(s),
                    "mean": f["mean"], "std": f["std"], "edge_density": f["edge_density"], "lapvar": f["lapvar"]})
    return top

def _symmetry(L: Dict[str, Any], R: Dict[str, Any]) -> Dict[str, float]:
    Lm = np.array(L["score_map"], dtype=np.float32); Rm = np.array(R["score_map"], dtype=np.float32)
    return {"left_total": float(Lm.mean()), "right_total": float(Rm.mean()), "delta": float(abs(Lm.mean()-Rm.mean()))}

def _render_heatmap_png(score_map: List[List[float]], out_path: Path) -> None:
    arr = np.array(score_map, dtype=np.float32)
    H, W = arr.shape[0]*10, arr.shape[1]*40
    img = Image.fromarray(np.uint8(_normalize01(arr)*255), mode="L").resize((W, H), Image.NEAREST)
    img.save(out_path)

def _save_report(exam_id: str, result: dict) -> str:
    root = INBOX / exam_id; root.mkdir(parents=True, exist_ok=True)
    meta = {"exam_id": exam_id, "age": result.get("age"), "gender": result.get("gender"), "task": result.get("task_received")}
    (root/"meta.json").write_text(json.dumps(meta, ensure_ascii=False, indent=2), encoding="utf-8")
    (root/"report.json").write_text(json.dumps(result, ensure_ascii=False, indent=2), encoding="utf-8")
    L = result.get("left", {}); R = result.get("right", {})
    if L.get("score_map"): _render_heatmap_png(L["score_map"], root/"heatmap_left.png")
    if R.get("score_map"): _render_heatmap_png(R["score_map"], root/"heatmap_right.png")
    return str(root)

def _synthesize_text(result: dict) -> str:
    parts=[]
    parts.append(f"Иридологический авто-черновик • ID={result.get('exam_id')} • Возраст={result.get('age')} • Пол={result.get('gender')}")
    L = result.get("left", {}); R = result.get("right", {})
    def add_side(name, d):
        q = d.get("quality", {})
        parts.append(f"{name}: яркость={q.get('brightness',0):.3f}, блики={q.get('glare',0):.3f}, резкость={q.get('sharp_lapvar',0):.1f}")
        tz = d.get("top_zones", [])[:5]
        if tz:
            parts.append(f"Топ-зоны {name}:")
            for z in tz:
                parts.append(f"• {z.get('label')} (score={z.get('score',0):.3f})")
    if L: add_side("ЛЕВЫЙ", L)
    if R: add_side("ПРАВЫЙ", R)
    sym = result.get("symmetry", {})
    if sym:
        parts.append(f"Симметрия: L={sym.get('left_total',0):.3f}, R={sym.get('right_total',0):.3f}, Δ={sym.get('delta',0):.3f}")
    parts.append("Комментарий: авто-черновик по эвристикам (v1). Не является медицинским заключением.")
    return "\\n".join(parts)

def _save_report_txt(exam_id: str, result: dict, root: Path) -> str:
    (root/"report.txt").write_text(_synthesize_text(result), encoding="utf-8")
    return str(root)

def _save_report_pdf(exam_id: str, result: dict, root: Path, locale: str = "en") -> str:
    _ensure_fonts()
    font_title = "Helvetica"
    font_text  = "Helvetica"
    pdf_path = root / "report.pdf"
    c = canvas.Canvas(str(pdf_path), pagesize=A4)
    w, h = A4
    y = h - 40
    margin_x = 40
    title = f"Iris Auto-Report • ID={result.get('exam_id') or exam_id} • Age={result.get('age')} • Gender={result.get('gender')}"
    title = _shape_rtl(title, locale)
    c.setFont("Helvetica", 12)
    c.drawString(margin_x, y, title); y -= 24
    txt = result.get("text_summary") or result.get("summary") or "No text summary"
    c.setFont("Helvetica", 10)
    max_width = w - margin_x*2
    for para in str(txt).splitlines():
        for line in _wrap_lines_for_pdf(para, max_width, font_text, 10, locale):
            if y < 160:
                c.showPage(); y = h - 40; c.setFont("Helvetica", 10)
            c.drawString(margin_x, y, line); y -= 14
        if y < 160:
            c.showPage(); y = h - 40; c.setFont("Helvetica", 10)
    c.showPage()
    c.setFont("Helvetica", 12)
    c.drawString(margin_x, h-40, _shape_rtl("Heatmaps", locale))
    c.setFont("Helvetica", 10)
    c.drawString(margin_x, h-60, _shape_rtl("Left", locale))
    c.drawString(320, h-60, _shape_rtl("Right", locale))
    def draw_img(path, x, y, maxw=240, maxh=240):

            img = ImageReader(str(path))
            c.drawImage(img, x, y, width=maxw, height=maxh, preserveAspectRatio=True, anchor='sw')

            pass
    left_png  = root / "heatmap_left.png"
    right_png = root / "heatmap_right.png"
    draw_img(left_png, 40,  h-320)
    draw_img(right_png, 320, h-320)
    c.showPage()
    c.save()
    return str(pdf_path)

@app.get("/")
def root():
    return {"status": "ok"}

@app.post("/analyze")
async def analyze(
    exam_id: str = Form(...),
    age: int = Form(...),
    gender: str = Form(...),
    locale: str = Form(default="en"),
    task: str = Form(default=""),
    left: UploadFile = File(...),
    right: UploadFile = File(...),
):
    Limg = Image.open(left.file).convert("RGB")
    Rimg = Image.open(right.file).convert("RGB")
    L = _score_map_and_features(Limg)
    R = _score_map_and_features(Rimg)
    Lf = L["features"]; Rf = R["features"]
    result = {
        "exam_id": exam_id, "age": age, "gender": gender, "task_received": task,
        "left":  {"quality": L["quality"], "quality_flags": _flags_quality(L["quality"]), "top_zones": _top_flags(Lf, 5), "score_map": L["score_map"]},
        "right": {"quality": R["quality"], "quality_flags": _flags_quality(R["quality"]), "top_zones": _top_flags(Rf, 5), "score_map": R["score_map"]},
        "symmetry": _symmetry(L, R),
        "summary": "v1: heatmap+symmetry (эвристика). Not a medical diagnosis."
    }
    out_dir = INBOX / exam_id
    out_dir.mkdir(parents=True, exist_ok=True)
    _save_report(exam_id, result)
    _save_report_txt(exam_id, result, out_dir)
    result["text_summary"] = _synthesize_text(result)
    _save_report_pdf(exam_id, result, out_dir, locale=locale)
    result["report_pdf"] = f"/files/{exam_id}/report.pdf"
    result["report_txt"] = f"/files/{exam_id}/report.txt"
    return JSONResponse(result)
