import 'dart:io';

import 'package:flutter/material.dart';
import 'package:hive/hive.dart';

import '../models/diagnosis_model.dart';
import '../services/export_import_service.dart';
import 'diagnosis_summary_screen.dart';

class HistoryScreen extends StatefulWidget {
  const HistoryScreen({super.key});

  @override
  State<HistoryScreen> createState() => _HistoryScreenState();
}

class _HistoryScreenState extends State<HistoryScreen> {
  late Future<Box<Diagnosis>> _boxFuture;

  @override
  void initState() {
    super.initState();
    _boxFuture = _openBox();
  }

  Future<Box<Diagnosis>> _openBox() async {
    if (Hive.isBoxOpen('diagnoses')) {
      return Hive.box<Diagnosis>('diagnoses');
    }
    return Hive.openBox<Diagnosis>('diagnoses');
  }

  Future<void> _doExport() async {
    try {
      await ExportImportService.exportZip(appVersion: '1.0.0');
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Экспорт завершён')),
      );
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Export error: $e')),
      );
    }
  }

  Future<void> _doImport(Box<Diagnosis> box) async {
    try {
      final n = await ExportImportService.importZip(merge: true);

      // box.watch() обычно сам триггерит перерисовку (потому что будут put/add),
      // но setState здесь — “ремень безопасности”.
      if (mounted) setState(() {});

      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Импортировано: $n')),
      );
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Import error: $e')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<Box<Diagnosis>>(
      future: _boxFuture,
      builder: (context, snap) {
        if (snap.connectionState != ConnectionState.done) {
          return const Scaffold(
            body: Center(child: CircularProgressIndicator()),
          );
        }
        if (snap.hasError) {
          return Scaffold(
            appBar: AppBar(title: const Text('История')),
            body: Center(child: Text('Ошибка: ${snap.error}')),
          );
        }

        final box = snap.data!;

        return Scaffold(
          appBar: AppBar(
            title: const Text('История'),
            actions: [
              IconButton(
                tooltip: 'Export',
                icon: const Icon(Icons.upload_file),
                onPressed: _doExport,
              ),
              IconButton(
                tooltip: 'Import',
                icon: const Icon(Icons.download),
                onPressed: () => _doImport(box),
              ),
            ],
          ),
          body: StreamBuilder(
            // Любое изменение в box (add/put/delete) → rebuild списка.
            stream: box.watch(),
            builder: (context, _) {
              final items = box.values.toList().cast<Diagnosis>();

              // Сортировка: новые сверху (если есть dateTime), иначе как есть.
              items.sort((a, b) {
                final adt = _tryGetDateTime(a);
                final bdt = _tryGetDateTime(b);
                if (adt == null && bdt == null) return 0;
                if (adt == null) return 1;
                if (bdt == null) return -1;
                return bdt.compareTo(adt);
              });

              if (items.isEmpty) {
                return const Center(child: Text('Пока нет обследований'));
              }

              return ListView.separated(
                itemCount: items.length,
                separatorBuilder: (_, __) => const Divider(height: 1),
                itemBuilder: (context, i) {
                  final d = items[i];

                  final leftPath = _tryGetLeftPath(d);
                  final rightPath = _tryGetRightPath(d);

                  final title = 'ID: ${d.id.toString()}';
                  final subtitle = _buildSubtitle(d);

                  return ListTile(
                    leading: _thumb(leftPath),
                    title: Text(title),
                    subtitle: Text(subtitle),
                    trailing: _thumb(rightPath),
                    onTap: () {
                      // Открываем Summary (у тебя он принимает leftPath/rightPath).
                      // Если у тебя сейчас другой конструктор — скажи, подстрою под твой.
                      Navigator.of(context).push(
                        MaterialPageRoute(
                          builder: (_) => DiagnosisSummaryScreen(
                            leftPath: leftPath ?? '',
                            rightPath: rightPath ?? '',
                          ),
                        ),
                      );
                    },
                  );
                },
              );
            },
          ),
        );
      },
    );
  }

  Widget _thumb(String? path) {
    if (path == null || path.isEmpty) {
      return const SizedBox(width: 56, height: 56);
    }
    final f = File(path);
    if (!f.existsSync()) {
      return const SizedBox(width: 56, height: 56);
    }
    return ClipRRect(
      borderRadius: BorderRadius.circular(8),
      child: Image.file(
        f,
        width: 56,
        height: 56,
        fit: BoxFit.cover,
      ),
    );
  }

  String _buildSubtitle(Diagnosis d) {
    final dt = _tryGetDateTime(d);
    final gender = _tryGetGender(d);
    final age = _tryGetAge(d);

    final parts = <String>[];
    if (dt != null) parts.add(_fmtDateTime(dt));
    if (gender != null && gender.isNotEmpty) parts.add(gender);
    if (age != null && age.isNotEmpty) parts.add('age: $age');

    return parts.isEmpty ? '—' : parts.join(' • ');
  }

  DateTime? _tryGetDateTime(Diagnosis d) {
    try {
      // если поле есть
      final v = (d as dynamic).dateTime;
      if (v is DateTime) return v;
    } catch (_) {}
    try {
      // запасной вариант: date может быть int (millis) или DateTime
      final v = (d as dynamic).date;
      if (v is DateTime) return v;
      if (v is int) return DateTime.fromMillisecondsSinceEpoch(v);
    } catch (_) {}
    return null;
  }

  String? _tryGetAge(Diagnosis d) {
    try {
      final v = (d as dynamic).age;
      return v?.toString();
    } catch (_) {}
    try {
      final v = (d as dynamic).birthYear;
      if (v == null) return null;
      return 'BY:$v';
    } catch (_) {}
    return null;
  }

  String? _tryGetGender(Diagnosis d) {
    try {
      final v = (d as dynamic).gender;
      return v?.toString();
    } catch (_) {}
    return null;
  }

  String? _tryGetLeftPath(Diagnosis d) {
    try {
      final v = (d as dynamic).leftEyeImagePath;
      return v?.toString();
    } catch (_) {}
    try {
      final v = (d as dynamic).leftPath;
      return v?.toString();
    } catch (_) {}
    return null;
  }

  String? _tryGetRightPath(Diagnosis d) {
    try {
      final v = (d as dynamic).rightEyeImagePath;
      return v?.toString();
    } catch (_) {}
    try {
      final v = (d as dynamic).rightPath;
      return v?.toString();
    } catch (_) {}
    return null;
  }

  String _fmtDateTime(DateTime dt) {
    final y = dt.year.toString().padLeft(4, '0');
    final m = dt.month.toString().padLeft(2, '0');
    final d = dt.day.toString().padLeft(2, '0');
    final hh = dt.hour.toString().padLeft(2, '0');
    final mm = dt.minute.toString().padLeft(2, '0');
    return '$y-$m-$d $hh:$mm';
  }
}
